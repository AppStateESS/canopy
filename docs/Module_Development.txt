Writing Modules for phpWebSite

PhpWebSite has come a long way since it was a phpNuke fork. In 0.8.x
it became modular. With 0.9.x it was rewritten from the ground up and
to become more of a platform for web programs.

Now that we approach the release of 0.9.4, phpWebSite is going through
another metamorphosis. There are new tools and techniques to create a
module. This document will attempt to take you through this process.

I am currently writing this document while 0.9.4 is still in the alpha
phase. There are still some key core components that need
development. However, before they can get written, a content module is
needed to work against. So while I develop the first native module for
0.9.4, I will go through the process to create it.

This document is expected to go through some change. I plan on
releasing it early (before 0.9.4's official release) and updating it
as features are added. Eventually, I hope the full powers of 0.9.4 are
reflected within.


Getting Started

First, decide the module's name and its function. We will be creating
creating a module to deal with links. It function will be to allow
users to submit links, categorize them, etc. Pretty simple actually
but it should contain enough functionality to cover the core's basics.
The name of the module will be simply "links".

Second, we need to create specific directories. Here are the ones I am
making along with why they need to be there.

phpwebsite/mod/links/
Our basic directory. It is important that the directory name is the
same as the module name.

The rest of the directories will be placed in the above directory.

boost/
This directory contains information on how to install, update, and
uninstall your module. 99% of the time, this is required.

class/
This directory contains your module's class files. (If you are not
programming using oop, you are going to have a great deal of
difficulty from this point on.)

conf/
This is where your configuration files are placed. These will be
copied to the phpwebsite/config/links/ directory upon
installation. These are copied so branches can each have
their own config file if they need it.

docs/
This is where we would put documentation on our module.

img/
Any images that are specific to our module need to go here. They will
be copied to images/mod/links/ when the module is installed.

inc/
Another important directory. This directory contains your modules
start up and close down files. More about this later.

lang/
Contains your po file translations. More about this later as well.

templates/
Contains your template files. These will be copied to
templates/mod/links/ on install.

Next we need to make the installation files. Remember I said earlier
that 99.9% of the time you needed to make a boost directory? You can
create a simple module that doesn't require installation and therefore
doesn't need most of the above directories.

Make a directory named 'example'.

Save a file named 'index.php' in that directory with the following
information.

<--------------- Start Code ------------------>
<?php

Layout::add("Hello World!");

?>
<--------------- End Code -------------------->

Now go to your phpwebsite installation. Now type the following at the
end of your address line:

index.php?module=example


When you go to the page, you should see "Hello World!" on your page.

Want to change make it a little more flashy?

Change the 'Layout' line to the following:

Layout::add(array("TITLE"=>"My First Module",
                  "CONTENT"=>"Hello World!"),
                  "exampleContent");

Now it should be in a box! Ok it's not that exciting, but that is the
most basic module you can design.


We on the other hand are going to make an installable module. So we
will be using Boost, the installation module in phpWebSite.

To get started, we need to give boost some basic information about our
module. This information will go into a file appropriately named
'boost.php'. It will be placed into the conf/ directory. In fact, any
time another module needs information about your module, it expects a
file to be in your conf directory. For example, the control panel
module will want icon and tab information. So we would create a
controlpanel.php file and put it in conf/. We will get into this in
more detail later.

The boost.php file will have the following variables:

proper_name - This is the title of the module. Ours will be "Links".

version - This number tracks the development of our module. The format
is 1.2.3. Minor fixes increment the last number (3). Large fixes
increment the second number (2). Major upgrades of a program increment
the first number (1). Since our module is brand new we will start with
0.0.1

register - If our module needs to perform an action when other modules
are installed, this is set to TRUE. For now, we will keep this at
FALSE.

unregister - If our module needs to perform an action when other
modules are uninstalled, then this is set to TRUE. Some modules (like
Layout) perform an action when a module is uninstalled but NOT when
one is installed.

import_sql = If this is set to TRUE, boost will look for a install.sql
file. We will be using this.

image_dir = If this module uses user submitted images, you would set
this to TRUE. Don't confuse this with images used by the
module. Submitted images are different than administrative icons and
the like. We can set this to FALSE.

file_dir = If your module needs a directory to save files to, change
this to TRUE. This will be FALSE for us.

about - If true then this module has an About file. The About file
just tells the admin who wrote the module, where the module is hosted
on the web, and other errata. We'll set this to TRUE.

version_http - You may want to keep a file somewhere that lets the
user know if they can get an updated copy. This variable stores the
web address to that file. We'll use this as well.

priority - Most of the time, you can leave this alone. Priority
determines the order that modules are loaded for execution. Some
modules, like users and layout, are very import to load first. The
default value is 50 but you can leave it blank. We will fill it in
just for instructional purposes.


So here is our boost.php file:

<?php
$proper_name  = "Links";
$version      = "0.0.1";
$register     = FALSE; // You could also leave this blank
$unregister   = FALSE; // Ditto
$import_sql   = TRUE;
$image_dir    = FALSE;
$file_dir     = FALSE;
$version_http = "http://phpwebsite.appstate.edu/updates/links.ini";
$about        = TRUE;
$priority     = 50;
?>

If you have links on your phpwebsite installation, some of this
information may have changed by the time you are reading this.

SQL
Although you can write a module without accessing the database, most
of the time you will. So we need to tell Boost what our database
tables look like.

The best way to do this process is to make the table in your database,
then export it.

First we need to decide the structure of the most common element in
our module. For links, that would be 'a link'. So lets create a table:

CREATE TABLE links_links

This looks strange because I am repeating the word 'links'
twice. However, the first part of the table name should always be the
name of your module followed by an underline. Everything beyond that,
describes what the table contains. In this case, the table holds
'links'. I could just as easily named it "links_href" or
"links_clickable_words_that_take_you_to_another_page".
I think using the word "links" again is sufficient. What is important
to note is that I am NOT using uppercase characters in my table
name. Uppercase letters can confused some databases. Not saying they
can't handle it, it is just that different databases handle it
differently. They all understand lowercase table and column
names. This allows your module to be instantly accessible by other
databases running phpwebsite. Just go ahead and do it.

Now I need to decide the structure of this table. Most of the time,
the first column you make will be the 'id' column. The 'id' of an item
(our 'item' is our link) gives it a number different from all the
other items in the table. So we need to make the id and integer (INT)
and also make it the primary key. This will accomplish two things.
1) When we ask for a link by its id, the database will find it faster
and
2) phpWebSite will automatically increment this number as we add more
links.

Here are some other columns I am going to create:

title - will hold the text displayed for the link.

description - a short description about the site. Don't use 'desc' as
a column name. The database won't like it.

keywords - words that we want associated with the link for searching

href - the actual link address itself

secure - whether the link is a secure link or not

user_id - the user_id of the person who submitted the link

active - switch to determine whether the link is seen or not

hits - records the amount of times a link has been clicked

created - lists the date a link was created

That should be sufficient for now. Here is what we will put in our
install.sql file.

CREATE TABLE links_links (
id INT NOT NULL ,
title VARCHAR( 255 ) NOT NULL ,
description TEXT NOT NULL ,
keywords TEXT NOT NULL ,
href VARCHAR( 255 ) NOT NULL ,
secure SMALLINT NOT NULL ,
user_id INT NOT NULL ,
active SMALLINT NOT NULL ,
hits INT NOT NULL ,
created INT NOT NULL ,
PRIMARY KEY ( id )
);

This was a MySQL export. Notice that it does not contain any back-ticks
(`). This is something specific to MySQL. It will confuse other
databases, so don't use it. Also notice that we did not use
TINYINT. They are MySQL specific. We also did not put integer lengths
in the define. They tend to break MicrosoftSQL.

This should be sufficient.

Since you have told phpWebSite that you are using an SQL file for
installation, it will expect one for uninstalling the module as
well. Fortunately, these are easy to make. Create a file named
uninstall.sql and just drop the data.

DROP TABLE links_links;

We are almost ready to install. The Links module requires an
administrative interface. The easiest way to do this, is to register
with the Control Panel module.

Before we make this file, lets take a look how the Control Panel
module creates a link on newly installed modules. If you look in the
mod/controlpanel/boost/ directory, you will see a file named
register.php. This file tells Boost what to do when a new module is
installed. Notice the function name at the top of the file,
"controlpanel_register". This is the function that Boost by
default. As you can see it is just moduleName_register. There are two
required parameters for the function, $module and $content.

Notice that the $content variable has an ampersand. This indicates
that the variable is being passed by reference. In other words,
what ever we do to the $content variable, effects the variable sent
by Boost. This lets the module return a specific value without having
to send back the content created by the function.

The 'module' variable is just the module's title. 

I won't get into the intricacies of the register file, but we can
follow what happens to our Links module.

The register function for Control Panel is going to be looking for a
registration file. It will look for that file in the conf/
directory. So lets make one!

Because you may want to make multiple links, control panel expects its
information in an array. Here is what variables we will be filling in:

label - the clickable text that will be next to the icon.

restricted - indicates whether this is a restricted module or if any
user can see it.

url - the address that instructs phpWebSite how to access it.

description - a short description of what the icon takes us to.

image - the name of the icon.

tab - the location to place the icon.


Here is our array to put into the controlpanel.php file:

$link[] = array("label"       => _("Links Administration"),
                "restricted"  => TRUE,
                "url"         =>
                "index.php?module=links&action=admin",
		"description" => _("Admin the links on your site."),
		"image"       => "links.png",
		"tab"         => "content"
                );

Now we just save that file in the conf/ directory. You can also add
tabs to Control Panel, but you will need to read its documentation.

Back to Control Panel's register function. It uses the 'module'
parameter to check for the existence of the file we just made. If it
sees it, it includes it and then inserts the various tabs and links
into the database. Meanwhile it reports its status by adding lines of
text to the 'content' array. If it was successful, it returns TRUE and
FALSE otherwise. To see exactly HOW Control Panel does this, you will
have to review the register.php file. One thing interesting to note is
that Control Panel registers itself when it gets installed. In other
words, when you install a module that has a register file it will:
1) register itself to itself,
2) register other modules to itself, and
3) get registered by other modules.

BTW, conversely if your module has a register.php file, it needs an
unregister.php file as well. This file will remove the changes it made
to a module when it gets uninstalled. For example, Control Panel drops
your icon when you uninstall your module.

There are two more files that can help with your module's
installation and uninstallation. They are install.php and
uninstall.php.

The install.php file will be included if found and Boost will attempt
to run a function entitled moduleName_install. For example, take a
look at the install.php file in mod/users/boost/. When the user module
is installed, it needs to create its first user. So it creates a form
for you to enter your user name and password. Remember when you were
installing phpWebSite? The new user form came from this file. This
file will also suspend the completion of a module's installation by
what it returns. The users_install function returns FALSE when it
isn't finished and TRUE when it is. If it returns an error object
(explained later) then Boost knows there was a problem and the module
doesn't get installed.

The uninstall file works the same way. When you are uninstalling a
module, it allows it to perform some last minute maintenance.

If the install file for users looks complicated, don't worry. Nine
times out of ten you won't need one.

Ready to install
Links is now ready to install. We just go to Boost, click on Other
Modules and click the install link. But wait, what about our About
file? This is really simple, just create a very small HTML web page
and drop it in your module's conf/ directory. You can click on About
to see the one that comes with Links.

Once you click Install, Boost should handle the rest. If there is a
problem, you should get a warning message from either your module (if
you wrote error messages in your register.php or install.php files) or
from Boost itself. Bad errors will appear in either the error.log or
boost.log file in your logs/ directory.

If there aren't any errors, then you should get a "Installation
Successful" message.

Writing the Code

Links is installed, but it doesn't DO anything. In fact, I usually
write a module first and worry about the install files at the very
end. This is because I usually don't know all the things that it
needs until the module is finished.

As I decide to add elements, I will discuss them here. It is debateable
whether that is the BEST way to teach you, but I think it is the best
way for you to learn what I know. Also, I don't plan everything out as
I go. Usually I write some code, come back, add to it, tweak, etc. But
when writing this documentation, we will pretend that I knew exactly
how the module would turn out in the end.

Before I continue, keep some things in mind. I will offer example code
that may NOT be in Links. For example, I will start testing the module
with sample code. This code will be removed before release. Most of
the time this code will be pretty minor.

Also, I will touch on some components of the core but I won't go in
detail about each module. That should be covered that module's
documentation. If I use every feature of every module, the Links
module will be a Frankenstein's monster of code. We will only use what
we need.

Ok first thing I want to do is create my index.php file. When
phpWebSite is told to use a specific module, it will route itself to
the index.php file contained within your module's directory. What
happens from that point on is up to you.

I am going to start with a basic admin structure. The first thing I
want to do is make a form to create links. To do so, I need a link
class. Look at the file Link.php in the class/ directory.

Notice the class name: Links_Link. I don't name it just 'Link' because
there is the slim possibility that 'Link' could become a class name
somewhere else. Get in the habit of prefixing your class names with
the name of your module.

The variable construction is simple: they are the same as the columns
in our link table. I am making all of these variables public.
(Note: php 4 doesn't really use public and private variables, but you
should get in the habit of thinking about them).

I am going to assign all these variables as NULL except for some
exceptions. 'User_id' is going to be set to 0. I figure that some
links may be posted anonomously. Since all users have ids above zero,
this will be a good indicator. 'Active', 'hits', and 'created' will be
defaulted to zero as well. I am also making a private value
'_error'. The underscore denotes it as 'private'.

Next I create the constructor with an id value parameter. The default
will be 'NULL' so I can construct a blank link object. If the id
parameter is available, I am going to run the init() function. If the
init() function fails it will return an error object. Because the
error happened in the constructor, I am going to store the error in
the _error variable and log the error.

Let's go over the error object. It would be in your best interest to
handle error reporting in this manner. PEAR (one of the php libraries
used extensively by phpWebSite) has a great error class. We use a
modified form of it.

To see how this works, take a look at the init() function. It is going
to select a link from the database that matches the id number sent to
it. One of three things could happen:
1) it finds the link in the database (that's good!),
2) it fails to find the link in the database (that's bad), or
3) there was an error trying to select from the database (real bad).

If the first condition happens, we just pass the information to the
rest of the function. If the second condition happens, then we need to
create our own error.

if (empty($result))
   return PHPWS_Error::get(LINKS_ERR_NOT_FOUND,
		           "links",
			   "Links_Link::init",
			   "id=" . $this->getId()
			   );

Two things we need setup for our error control to function. First, we
should define our error codes. You can set your codes however you wish
however I find the easiest way is to define negative number values to
descriptive code names. For example, in init you see the define
LINKS_ERR_LINK_NOT_FOUND. All my error codes will be prefixed by
LINKS_ERR. The rest of the code tells me what it is for. You can put
these codes where ever you wish. The best place would be at the top of
the class or in a config file. The advantage of a config file is that
all your errors are in one place and you won't have a number overlap.
I put my error codes in the conf/config.php file.

Next I need to write an explanation of the error. I save these to the
conf/ directory in a file named 'error.php'. Take a look at that
file. I create an array named 'errors'. The key of each error is the
define we made earlier and the value of the array row is the message.

Back to the init function. Notice that we check for an empty
result. If that is the case, a null was returned and we need to return
the error we created using the PHPWS_Error::get function.

PHPWS_Error::get(error_id, module_name, [class_name::]function_name, extra_data);

The result will be an PEAR error object. Notice that I put the name of
the class along with the function. If your function has a generic name
(get, load, init, etc.), putting the class name will help you track
down where the error originated.

We can do a couple of things with the error object. We can print it
using PHPWS_Error::printError(), or we can log it using
PHPWS_Error::log(). In Links case, I am logging the error and then
copying it to the _error variable. The error will show up in
logs/error.log if it occurs.

If the result passes the empty check, I am checking to see if the
result is an error object.

elseif (PEAR::isError($result))
  return $result;

If it is an error I am just returning it instead of creating my own
error object. When writing your module, you should "pass the buck" like
this as well. It will allow you to get to the root of the problem and
avoid redundant code.


The Administration Menu

I want to start getting some data into our database. What I am going
to do is create a form to enter information about our link, check the
information for errors, put the information into a link object, and
save it to the database.

First we have a decision to make. How do we access the link creation?
Remember that we are coming from the control panel link we made on
installation. This is what I am thinking: we will have two tabs, one
called 'New' and one called 'Edit'. The 'New' link will take them to
the creation of a new link. 'Edit' will take them to a listing of
links so they can be administrated.

First thing I am going to do is make an Action.php class. This class
will handle the various requests that come into the module. That is
its only purpose. Look at the Action.php file.

Now I need to require this file in the index.php file so I can use it.
PHPWS_Core::initModClass("links", "Action.php");

I could just as easily done it this way:
require_once PHPWS_SOURCE_DIR . "mod/links/class/Action.php";

However, the initModClass does this for me. It will also silence an
error and log it, if the file is missing. Do whichever way you
prefer. Do make sure that you use 'require_once' instead of simply
'require'. That makes sure a class is not redeclared.

By the way, the PHPWS_SOURCE_DIR is defined as the default directory
for your installation. This can be very important if you want your
module to be branch* compatible.

Something else that I am going to add is a reroute at the top of the
index file. I am going to use our source directory definition from
above.

if (!defined("PHPWS_SOURCE_DIR")){
  header("location:../../index.php");
  exit();
}

This will send someone who is trying to access the index.php file
directly back to our home page. Notice I put it before the class
inclusions. If I didn't they wouldn't work and phpWebSite would print
an error. Try to prevent users from seeing errors at all times.

Since I know that I will have user and administrative functionality, I
create some division of process:

if ($_REQUEST['action'] == 'admin'){
  Links_Action::admin();
}
elseif ($_REQUEST['user']){
  Links_Action::user();
}

The admin function will take care of administrative options and the
user function will take care of user options.

Of course you can do this any way you wish. Create a class named
Admin.php and one named User.php and launch functions from there. Put
a switch statement in the index to handle all the requests. It is up
to you.

Back to the Links_Action class, I have a function for admin and user
options. I'll be working on the administrative portion first. I like
to have my major module options in a tabbed format. To do so, I use
the control panel module. It lets me embed my tabs within the
phpWebSite control panel. This just lets the site admin work with in
an easier interface.

To see how this is done, look at the cpanel() function. It creates the
links that I need:

$newLink = "index.php?module=links&amp;action=admin";
$newCommand = array ("title"=>_("New"), "link"=> $newLink);
	
$listLink = "index.php?module=links&amp;action=admin";
$listCommand = array ("title"=>_("List"), "link"=> $listLink);

Then I put them in an array:
$tabs['new'] = $newCommand;
$tabs['list'] = $listCommand;

I create a control panel object:
$panel = & new PHPWS_Panel("links");

Put the links in it:
$panel->quickSetTabs($tabs);

And return the result with $panel->display($content);

The content appears beneath the tabs. To get my panel to be surrounded
by the main control panel, I just use its display function:
PHPWS_ControlPanel::display($panel->display($content));

Now I just return the result and put it in the Layout.

Using Layout
Getting your code to display in phpWebSite is simple. Every theme has
a BODY tag (you will read about tags and template later). The BODY tag
is where the main portion of content gets displayed. Usually, it
doesn't share its space with other modules (though it is
possible). For our administrative panel we KNOW that it is the only
thing we want in the main content area. So we just send our content to
Layout like so:

Layout::add($content);

However, you may not want to put content in the BODY. You may want to
create content in a small box to the side or above the BODY. To do so,
you need to tell the Layout module to store the content.

Layout::add($content, $module_name, $marker);

So say for links I may want a small side box:

Layout::add($content, "links", "sideBox");

When ever I want to use that box, I make sure I use the same marker
name. If I want to add more data to the sideBox I can just call the
add() function again. It will append the text, not replace it.



Accessing the Database
A special database class was written for phpWebSite. Once you know how
it works, it can make database queries much easier. If you want to
know more about how it works, look up the Database class documentation
in this directory.





Glossary
-------------------------------------------------------------------
define - a constant variable.
See http://www.php.net/manual/en/function.define.php

branch - An installation of phpWebSite that shares the files from a
central hub. This allows several sites on the same server using one
set of code.
