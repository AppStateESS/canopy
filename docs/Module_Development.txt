Writing Modules for phpWebSite
by Matthew McNaney

-----------------------------------------------------------------------
I.   Introduction

II.  Programming
   A. Programming Style
     1. Classes
     2. Sessions
   B. Debug
   C. Database Interaction
     1. Format
     2. loadObject and saveObject
   D. Text
     1. Input
     2. Output
     3. Links
     4. User text
   E. Language
   F. Templating
   G. Error Handling
   H. Security

III. Installation
   A. Modules
   B. Directories
   C. Boost

IV.  Administrating
   A. Permissions
   B. Control Panel
   C. Settings
   D. Form Class
   E. Files
     1. Images
     2. Files
   F. DBPager
   G. Mini Admin

V.   Users and Layouts
   A. Layout
   B. Javascript
   C. Key Flag
   D. Caching

VI.  Advanced and Miscellaneous
   A. Approval
   B. Versioning
   C. Cookies
   D. SmartTags

----------------------------------------------------------------------

I. Introduction
______________________________________________________________________

PhpWebSite has come a long way since it was a phpNuke fork. In 0.8.x
it became modular. With 0.x it was rewritten from the ground up and
to become more of a platform for web programs.

Now that we approach the release of 1.x, phpWebSite is going through
another metamorphosis. There are new tools and techniques to create a
module. This document will attempt to take you through this process.

Please note that the original version of this document was written
during the alpha stages of 1.0.0. We are much closer to release
now. Originally started two years ago, much has changed since. I have
rewritten this document to reflect these changes.

Quick note: whenever I refer to an "item", I am expressing shorthand
for any type of content in your module. A blog entry, calendar event,
house listing, comment, etc. are "items".


II.  Programming
______________________________________________________________________

Every one codes differently. When I started writing phpws, PHP itself
was in version 4. As we get close to our release, PHP 5 installations
are more frequent. PHP's current class structure is much different.
More talented programmers are bound to scoff at my coding
technique. That's ok. It just happens to be the way I learned. I hope
to develop along with my code. Keeping that mind, feel free to deviate
from my coding samples. You may want to copy my code to get started
but develop your own technique.


A. Programming style
----------------------------------------------------------------------

1. Classes
......................................................................

phpWebSite 1.0 is almost entirely class based. If you are not familiar
with Object Oriented Programming, you may have problems from here
on. I would suggest reading some OOP documentation and code some
examples. Let me repeat the warning from above: my OOP coding may vary
wildly from "the standard" however it works for me. Use coding methods
you find comfortable.

You will find that many of the core classes use static calls. Others
depend on a constructed object. I suggest that if you have a simple
function that other modules could use to make it a static call. I like
static calls because they are easier to remember. A more complex class
may require a constructed object.

For example, PHPWS_Text has two functions (which I will cover in a
bit) that parse input and output text.

$text = PHPWS_Text::parseInput($input);
echo PHPWS_Text::parseOuput($text);

Simple. The database class has a static call as well:

PHPWS_DB::query('SELECT id from mytable');

You will tend, however, to contruct a database object most of the time
because of its complexity:

$db = & new PHPWS_DB('table_name');
$db->addWhere('column_name', 'foo');
$db->loadObject($object);


2. Sessions
......................................................................
Sessions can be very helpful. They prevent redundant object
construction, relay information without forms, links, or cookies, and
generally simplify coding. That said, avoid them when possible.

In phpWebSite 0.10.x and under, we couldn't get enough of sessions. We
also tended to overuse them. This caused memory bloat and required
constant vigilance of values. In phpWebSite 1.0, we try and use them
sparingly. You should as well.

I would also recommend avoiding sessioned objects. Although it isn't
hard to make sure their class is included before a session creation
(which is required), it can tend to be a pain.


B. Debug
----------------------------------------------------------------------

Those familiar with 0.10.x may remember the good ole testArray and
testObject function:

echo phpws_debug::testarray($some_array);
echo phpws_debug::testobject($some_object);

These still exist in phpWebSite 1.0, but they have been combined to
just "test":

test($some_array);
test($some_object);
test($some_string);

Notice you don't need to add echo.

The "test" function will recognize the type of variable passed to it
and behave appropiately. test() will change html tags to readable to
special characters for readability.

test() accepts two extra parameters. The second parameter tells test()
to exit after echoing the result, like so:

test($some_array, true);

Normally, test ignores redundant arrays and objects. You may bypass
this by entering 'true' in the third parameter:

test($some_array, true, true);

Beware. Allowing recursive printing could cause a memory overflow:

$foo = new Foo;
$bar = new Bar;

$bar->foo = &$foo;
$foo->bar = &$bar;

test($foo, false, false); // Expect a crash!


C. Database Interaction
----------------------------------------------------------------------
phpWebSite uses the PEAR Database class. This library allows multiple
database type (MySQL, Postgresql, Oracle, etc.)
interaction. phpWebSite also uses its own special database class named
PHPWS_DB. This class handles the connection and most basic queries. You
should familiarize yourself with it by reading the Database_Class.txt
file in the docs directory.


1. Format
......................................................................
Since you want your module to work independent from the database
platform, you should construct your queries carefully. Great effort
was put into the PHPWS_DB class to allow it to conform to separate
platforms. When possible, you should use it instead of constructing
your own queries. Also, security measures in PHPWS_DB class try to
prevent database hijacking.


2. loadObject and saveObject
......................................................................
Two very useful functions to note are loadObject and saveObject.
When you create an item class, your variable names should mirror the
column names.

For example, this class:

class foo {
 var $id    = 0;
 var $title = null;
}

Should have a table like so:

CREATE TABLE foo {
id INT NOT NULL,
title VARCHAR(255),
primary key ('id')
};

If you sync the variables and columns, loadObject and saveObject will
simplify your life. Here is how you can easily load an object from the
database. First I create the constructor function for "foo".


class foo {
 var $id    = 0;
 var $title = null;

  function foo($id=0) {
     if ($id) {
         $db = & new PHPWS_DB('foo_table'); // the foo table

         $this->id = (int)$id; // id exists, set the id

         $db->loadObject($this);
     }
  }
}

Now I can create my object.

$foo = & new foo(5);

The constructor will set the id, pull that row from table, and set the
variables for that object (just title in this example).

Now I can change the object and save the results with saveObject.

$foo->title = 'Better title';

$db = & new PHPWS_DB('foo_table');
$db->saveObject($foo);


These two functions are the foundation of your item class.


D. Text

It should go without saying that a majority of the information we will
be working with is text inputted by the user and text outputted by the
software. The amount of text tends to create issues and problems. How
do we save the text? How is the text displayed? How can we be sure the
text is safe? Which html tags will we allow? 

phpWebSite has a special text class to assist you with these issues.


1. Input
......................................................................
All input needs to be secured before going into the
database. Although the database class tries to prevent malacious
actions, it is best to parse the text before saving it.

Use parseInput before setting your object's text variables. I usually
use something like the following example:

$foo->setSummary($_POST['summary');

class foo {
....

function setSummary($summary) {
    $this->summary = PHPWS_Text::parseInput($summary);
}

parseInput will encode all the html tags, remove problematic Windows
characters, and change local web address to relative links.

Now the information contained in $foo->summary is ready to be saved.


2. Output
......................................................................
Now we need to display our text. We can use parseOutput.

echo $foo->getSummary();

function getSummary()
{
   return PHPWS_Text::parseOutput($this->summary);
}

parseOutput does more work than parseInput. It will:
1) Decode the html characters (encoded previously in parseInput)
2) change bbcode into html tags
3) remove profanity
4) strip tags we don't wish to allow
5) properly replace newline breaks with html breaks
6) translate various symbols into XHTML acceptable coding



3. Links
......................................................................
There are a handful of functions in the Text class that can assist you
with html links. Although permanent links are easier to type out, you
may find these functions help with the dynamic ones.


PHPWS_Text::moduleLink($subject, $module, $variables,
                       $target, $title);

moduleLink creates a phpWebSite relative link. For example:

$party_vars['city'] = 'Boone';
$party_vars['house_id'] = 5;

PHPWS_Text::moduleLink('Party at Jay\'s house', 
                       'party_mod',
                       $party_vars,
                       'blank',
                       'Directions to Jay\'s');

The above will create:

<a 
href="index.php?module=party_mod&amp;city=Boone&amp;house_id=5"
title="Directions to Jay's" target="_blank">
Party at Jay's house
</a>

The target and title variables are optional.


Sometimes you may want to create a more secure link. secureLink does
this for you. It works exactly like moduleLink except it adds an
authorization key to the end of the link.

PHPWS_Text::secureLink($subject, $module, $variables, $target, $title);

The authorization key works with the permissioning system in
phpWebSite. It makes sure the person arriving at an administrative
option is actually coming from the site and is logged in.

Here is another example. Let's say that someone was able to create a
bogus link somewhere on your site to exploit a weakness in the
software:

<img src="index.php?module=users&make_user_admin=6" />

Now if user number 6 went to that address, nothing would happen
because they don't have that priviledge. However, when you, an admin,
log on, that image tag could send a command to the user module to make
user 6 an admin. Since YOU had permissions, it would get through.

With the authorization key, the above would fail because the security
check would be expecting it. Since the hacker can't foresee what your
authorization code will be the moment you log on, they have little
chance of guessing the code.


If you want to use a link like the above but want the href information
only, you can use linkAddress:

PHPWS_Text::linkAddress($module, $variables, $secure,
                        $add_base, $convert_amp);

The first two parameters should be familiar. The last three are
optional, If "secure" is true, the authorization key will be added to
the link. If "add_base" is true, the full site address will be
prefixed to the address (i.e. http:://mysite.com/index.php... etc.).
Finally, if "convert_amp" is true, all the ampersands will be
converted into XHTML appropiate &amp;. You may want to set this to
false if you are using a header.


Finally, if you want to use short links via mod_rewrite, you can use
the rewriteLink function:

PHPWS_Text::rewriteLink($subject, $module, $id, $page);

Example:

echo PHPWS_Text::rewriteLink('Read more', 'newspaper', 6, 2);

The above would print:

<a href="/newspaper/6/2">Read more</a>

If not using Apache or mod_rewrite is disabled, you will get a normal
link.

<a href="index.php?module=newspaper&id=6&page=2">Read more</a>

Please familiarize yourself with mod_rewrite and .htaccess file
formatting before using the above.


4. User text
......................................................................
Some final notes before leaving the text discussion. Don't ever trust
user input ESPECIALLY anonymous input. Comments, for example, strips
all tags from user input. If they aren't using bb encoding, they don't
get to format the text. This is for your own safety.

As careful as I have been, I am SURE that somewhere I have left a
variable open that can be exploited. It is inevitable. Get in the
habit of testing all user data. Cast data types. Strip tags. Don't
allow file uploads. If you allow any of the above, parse the mess out
of it.

Testing text doesn't stop at form entry either. Parse cookies. Expect
someone to try and hack any input into the system.



E. Language
----------------------------------------------------------------------



F. Templating
----------------------------------------------------------------------



G. Error Handling
----------------------------------------------------------------------



H. Security
----------------------------------------------------------------------


III. Installation
______________________________________________________________________

   A. Modules
----------------------------------------------------------------------



   B. Directories
----------------------------------------------------------------------



   C. Boost
----------------------------------------------------------------------



IV.  Administrating
______________________________________________________________________


   A. Permissions
----------------------------------------------------------------------



   B. Control Panel
----------------------------------------------------------------------



   C. Settings
----------------------------------------------------------------------



   D. Form Class
----------------------------------------------------------------------



   E. Files
----------------------------------------------------------------------



     1. Images
......................................................................



     2. Files
......................................................................



   F. DBPager
----------------------------------------------------------------------



   G. Mini Admin
----------------------------------------------------------------------




V.   Users and Layouts
______________________________________________________________________



   A. Layout
----------------------------------------------------------------------



   B. Javascript
----------------------------------------------------------------------



   C. Key Flag
----------------------------------------------------------------------



   D. Caching
----------------------------------------------------------------------




VI.  Advanced and Miscellaneous
______________________________________________________________________



   A. Approval
----------------------------------------------------------------------



   B. Versioning
----------------------------------------------------------------------


   C. Cookies
----------------------------------------------------------------------



   D. SmartTags
----------------------------------------------------------------------

