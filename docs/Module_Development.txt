Writing Modules for phpWebSite
by Matthew McNaney

-----------------------------------------------------------------------
I.   Introduction

II.  Programming
   A. Programming Style
     1. Classes
     2. Sessions
   B. Debug
   C. Database Interaction
     1. Format
     2. loadObject and saveObject
   D. Text
     1. Input
     2. Output
     3. Links
     4. User text
   E. Language
   F. Templating
   G. Error Handling
   H. Security

III. Installation
   A. Modules
   B. Directories
   C. Boost
   D. Permissions
   E. Control Panel

IV.  Administrating
   A. Permissions
   B. Control Panel
   C. Settings
   D. Form Class
   E. Files
     1. Images
     2. Files
   F. DBPager
   G. Mini Admin

V.   Users and Layouts
   A. Layout
   B. Javascript
   C. Key Flag
   D. Caching

VI.  Advanced and Miscellaneous
   A. Approval
   B. Versioning
   C. Cookies
   D. SmartTags

----------------------------------------------------------------------

I. Introduction
______________________________________________________________________

PhpWebSite has come a long way since it was a phpNuke fork. In 0.8.x
it became modular. With 0.x it was rewritten from the ground up and
to become more of a platform for web programs.

Now that we approach the release of 1.x, phpWebSite is going through
another metamorphosis. There are new tools and techniques to create a
module. This document will attempt to take you through this process.

Please note that the original version of this document was written
during the alpha stages of 1.0.0. We are much closer to release
now. Originally started two years ago, much has changed since. I have
rewritten this document to reflect these changes.

Quick note: whenever I refer to an "item", I am expressing shorthand
for any type of content in your module. A blog entry, calendar event,
house listing, comment, etc. are "items".


II.  Programming
______________________________________________________________________

Every one codes differently. When I started writing phpws, PHP itself
was in version 4. As we get close to our release, PHP 5 installations
are more frequent. PHP's current class structure is much different.
More talented programmers are bound to scoff at my coding
technique. That's ok. It just happens to be the way I learned. I hope
to develop along with my code. Keeping that mind, feel free to deviate
from my coding samples. You may want to copy my code to get started
but develop your own technique.


A. Programming style
----------------------------------------------------------------------

1. Classes
......................................................................

phpWebSite 1.0 is almost entirely class based. If you are not familiar
with Object Oriented Programming, you may have problems from here
on. I would suggest reading some OOP documentation and code some
examples. Let me repeat the warning from above: my OOP coding may vary
wildly from "the standard" however it works for me. Use coding methods
you find comfortable.

You will find that many of the core classes use static calls. Others
depend on a constructed object. I suggest that if you have a simple
function that other modules could use to make it a static call. I like
static calls because they are easier to remember. A more complex class
may require a constructed object.

For example, PHPWS_Text has two functions (which I will cover in a
bit) that parse input and output text.

$text = PHPWS_Text::parseInput($input);
echo PHPWS_Text::parseOuput($text);

Simple. The database class has a static call as well:

PHPWS_DB::query('SELECT id from mytable');

You will tend, however, to contruct a database object most of the time
because of its complexity:

$db = & new PHPWS_DB('table_name');
$db->addWhere('column_name', 'foo');
$db->loadObject($object);


2. Sessions
......................................................................
Sessions can be very helpful. They prevent redundant object
construction, relay information without forms, links, or cookies, and
generally simplify coding. That said, avoid them when possible.

In phpWebSite 0.10.x and under, we couldn't get enough of sessions. We
also tended to overuse them. This caused memory bloat and required
constant vigilance of values. In phpWebSite 1.0, we try and use them
sparingly. You should as well.

I would also recommend avoiding sessioned objects. Although it isn't
hard to make sure their class is included before a session creation
(which is required), it can tend to be a pain.


B. Debug
----------------------------------------------------------------------

Those familiar with 0.10.x may remember the good ole testArray and
testObject function:

echo phpws_debug::testarray($some_array);
echo phpws_debug::testobject($some_object);

These still exist in phpWebSite 1.0, but they have been combined to
just "test":

test($some_array);
test($some_object);
test($some_string);

Notice you don't need to add echo.

The "test" function will recognize the type of variable passed to it
and behave appropiately. test() will change html tags to readable to
special characters for readability.

test() accepts two extra parameters. The second parameter tells test()
to exit after echoing the result, like so:

test($some_array, true);

Normally, test ignores redundant arrays and objects. You may bypass
this by entering 'true' in the third parameter:

test($some_array, true, true);

Beware. Allowing recursive printing could cause a memory overflow:

$foo = new Foo;
$bar = new Bar;

$bar->foo = &$foo;
$foo->bar = &$bar;

test($foo, false, false); // Expect a crash!


C. Database Interaction
----------------------------------------------------------------------
phpWebSite uses the PEAR Database class. This library allows multiple
database type (MySQL, Postgresql, Oracle, etc.)
interaction. phpWebSite also uses its own special database class named
PHPWS_DB. This class handles the connection and most basic queries. You
should familiarize yourself with it by reading the Database_Class.txt
file in the docs directory.


1. Format
......................................................................
Since you want your module to work independent from the database
platform, you should construct your queries carefully. Great effort
was put into the PHPWS_DB class to allow it to conform to separate
platforms. When possible, you should use it instead of constructing
your own queries. Also, security measures in PHPWS_DB class try to
prevent database hijacking.


2. loadObject and saveObject
......................................................................
Two very useful functions to note are loadObject and saveObject.
When you create an item class, your variable names should mirror the
column names.

For example, this class:

class foo {
 var $id    = 0;
 var $title = null;
}

Should have a table like so:

CREATE TABLE foo {
id INT NOT NULL,
title VARCHAR(255),
primary key ('id')
};

If you sync the variables and columns, loadObject and saveObject will
simplify your life. Here is how you can easily load an object from the
database. First I create the constructor function for "foo".


class foo {
 var $id    = 0;
 var $title = null;

  function foo($id=0) {
     if ($id) {
         $db = & new PHPWS_DB('foo_table'); // the foo table

         $this->id = (int)$id; // id exists, set the id

         $db->loadObject($this);
     }
  }
}

Now I can create my object.

$foo = & new foo(5);

The constructor will set the id, pull that row from table, and set the
variables for that object (just title in this example).

Now I can change the object and save the results with saveObject.

$foo->title = 'Better title';

$db = & new PHPWS_DB('foo_table');
$db->saveObject($foo);


These two functions are the foundation of your item class.


D. Text

It should go without saying that a majority of the information we will
be working with is text inputted by the user and text outputted by the
software. The amount of text tends to create issues and problems. How
do we save the text? How is the text displayed? How can we be sure the
text is safe? Which html tags will we allow? 

phpWebSite has a special text class to assist you with these issues.


1. Input
......................................................................
All input needs to be secured before going into the
database. Although the database class tries to prevent malacious
actions, it is best to parse the text before saving it.

Use parseInput before setting your object's text variables. I usually
use something like the following example:

$foo->setSummary($_POST['summary');

class foo {
....

function setSummary($summary) {
    $this->summary = PHPWS_Text::parseInput($summary);
}

parseInput will encode all the html tags, remove problematic Windows
characters, and change local web address to relative links.

Now the information contained in $foo->summary is ready to be saved.


2. Output
......................................................................
Now we need to display our text. We can use parseOutput.

echo $foo->getSummary();

function getSummary()
{
   return PHPWS_Text::parseOutput($this->summary);
}

parseOutput does more work than parseInput. It will:
1) Decode the html characters (encoded previously in parseInput)
2) change bbcode into html tags
3) remove profanity
4) strip tags we don't wish to allow
5) properly replace newline breaks with html breaks
6) translate various symbols into XHTML acceptable coding



3. Links
......................................................................
There are a handful of functions in the Text class that can assist you
with html links. Although permanent links are easier to type out, you
may find these functions help with the dynamic ones.


PHPWS_Text::moduleLink($subject, $module, $variables,
                       $target, $title);

moduleLink creates a phpWebSite relative link. For example:

$party_vars['city'] = 'Boone';
$party_vars['house_id'] = 5;

PHPWS_Text::moduleLink('Party at Jay\'s house', 
                       'party_mod',
                       $party_vars,
                       'blank',
                       'Directions to Jay\'s');

The above will create:

<a 
href="index.php?module=party_mod&amp;city=Boone&amp;house_id=5"
title="Directions to Jay's" target="_blank">
Party at Jay's house
</a>

The target and title variables are optional.


Sometimes you may want to create a more secure link. secureLink does
this for you. It works exactly like moduleLink except it adds an
authorization key to the end of the link.

PHPWS_Text::secureLink($subject, $module, $variables, $target, $title);

The authorization key works with the permissioning system in
phpWebSite. It makes sure the person arriving at an administrative
option is actually coming from the site and is logged in.

Here is another example. Let's say that someone was able to create a
bogus link somewhere on your site to exploit a weakness in the
software:

<img src="index.php?module=users&make_user_admin=6" />

Now if user number 6 went to that address, nothing would happen
because they don't have that priviledge. However, when you, an admin,
log on, that image tag could send a command to the user module to make
user 6 an admin. Since YOU had permissions, it would get through.

With the authorization key, the above would fail because the security
check would be expecting it. Since the hacker can't foresee what your
authorization code will be the moment you log on, they have little
chance of guessing the code.


If you want to use a link like the above but want the href information
only, you can use linkAddress:

PHPWS_Text::linkAddress($module, $variables, $secure,
                        $add_base, $convert_amp);

The first two parameters should be familiar. The last three are
optional, If "secure" is true, the authorization key will be added to
the link. If "add_base" is true, the full site address will be
prefixed to the address (i.e. http:://mysite.com/index.php... etc.).
Finally, if "convert_amp" is true, all the ampersands will be
converted into XHTML appropiate &amp;. You may want to set this to
false if you are using a header.


Finally, if you want to use short links via mod_rewrite, you can use
the rewriteLink function:

PHPWS_Text::rewriteLink($subject, $module, $id, $page);

Example:

echo PHPWS_Text::rewriteLink('Read more', 'newspaper', 6, 2);

The above would print:

<a href="/newspaper/6/2">Read more</a>

If not using Apache or mod_rewrite is disabled, you will get a normal
link.

<a href="index.php?module=newspaper&id=6&page=2">Read more</a>

Please familiarize yourself with mod_rewrite and .htaccess file
formatting before using the above.


4. User text
......................................................................
Some final notes before leaving the text discussion. Don't ever trust
user input ESPECIALLY anonymous input. Comments, for example, strips
all tags from user input. If they aren't using bb encoding, they don't
get to format the text. This is for your own safety.

As careful as I have been, I am SURE that somewhere I have left a
variable open that can be exploited. It is inevitable. Get in the
habit of testing all user data. Cast data types. Strip tags. Don't
allow file uploads. If you allow any of the above, parse the mess out
of it.

Testing text doesn't stop at form entry either. Parse cookies. Expect
someone to try and hack any input into the system.


E. Language
----------------------------------------------------------------------
phpWebSite 1.0 uses the gettext method of language translation. There
are several benefits using gettext over the old method. First, there
isn't an extra language session taking up memory. Second, it is easier
to develop code around it. Third, editing the files is simple and
there are many client programs that perform this function.

The downside is that gettext must be compiled on the machine. This
isn't that much of a problem on most Linux machines but may cause a
problem with custom builds or Windows servers.

Translating static text in your module is easy:

_('Translate this text');

Surround your text with underline, left then right parenthesis. The
underline is short for gettext();

When you have dynamic content in your translation, use printf or
sprintf like so:

printf(_('Good morning %s, how are you?'), 'Ted');

This way the translator can move the "%s" around.

You can learn more about gettext and translation in the
docs/Language.txt file.



F. Templating
----------------------------------------------------------------------
Whenever possible, you should avoid putting html mark up in your
code. Layout and style should be governed by template files.

Template files are typically html encoded files containing special
content tags. You can insert content into these content tags using the
PHPWS_Template class.

Example:

The template - greeting.tpl
----------------------------

<h1>{GREETING}</h1>
<p>{INFORMATION}</p>



The code:
----------------------------
$template['INFORMATION'] = 'We hope you are well';

$template['GREETING'] = sprintf(_('Good morning %s, how are you?'),
                                'Ted');

echo PHPWS_Template::process($template, 'my_module', 'greeting.tpl');


The result:
----------------------------
<h1>Good morning Ted, how are you</h1>
<p>We hope you are well</p>


This is just the basics of templating. Make sure to read
docs/template.txt for more information.



G. Error Handling
----------------------------------------------------------------------
Stuff happens (keeping this G rated y'all). Sometimes things go wrong
in your module or in others. phpWebSite uses PEAR's error class for
problem identification.

PEAR's error class constructs an error object. These objects are easy
to identify with "isError".

$result = getError();

if (PEAR::isError($result)) {
   exit('An error occurred');
}

Rarely will you just exit however. Instead you need to report the
error to the user and the site administrator.

The PHPWS_Error class extends the PEAR error class. You can use this
class to create your own error object.

For example, say you have a function that takes an id greater than
zero. If the id is zero, then something went wrong. We would use the
"get" function.

function load($id, $name_of_req) {
     if ($id) {
         loadItem($id, $name_of_req);
     } else {
         return PHPWS_Error::get(ERROR_CODE, 'my_module', 'load',
                                 $name_of_req);
     }
}


In the above example, an error object is returned with these
variables:

ERROR_CODE   - A predefined number indicating the problem
my_module    - The module the error occurred in
load         - The name of the function the error occurred in
$name_of_req - This is extra information. In this case, the name of the
               user that requested the load. This parameter is
               optional.

The ERROR_CODE is established earlier. I usually create a file named
error_defines.php and include it when the module starts.


inc/error_defines.php

<?php

    define('ERROR_CODE', -1);
   
?>


The ERROR_CODE corresponds to a message set in my conf/error.php file:

conf/error.php

<?php

    $errors = array(ERROR_CODE, _('Received a zero id.'));
   
?>

The error class will look for the error.php file to get the proper
message. The errors can be defined where ever you wish EXCEPT in the
error.php file itself. The error.php may be called more than once and
you can't have a repeating define function.

Once you have an error object, you can print the message:

echo $error->printError();

You can also use the PEAR functions getUserInfo and getMessage.

If the error message doesn't need to be seen by the user, you can
simply log it:

PHPWS_Error::log(ERROR_CODE, 'my_module', 'load', $name_of_req);

If you received the error object from another source, you can log it
directly:

PHPWS_Error::log($error_object);

These errors are written to your logs/error.log file.


What is great about error objects is the ability to pass them up. For
example look at the below.

function foo()
{
        $bar = bar();
        if (PEAR::isError($result)) {
           return $result;
        } else {
           process_something($result);
           return true;
        }
}

function bar()
{
        $result = load_something();
        if (PEAR::isError($result)) {
           return $result;
        } else {
           return true;
        }
        
}

$result = foo();
if (PEAR::isError($result)) {
     PHPWS_Error::log($result);
     echo 'Something is broken.';
} else {
     echo 'something loaded and processed successfully!';
}


In this case, the error could start in bar(), pass up to foo(), then
get passed to the result variable. We can then log the error and give
the user a useful (or not so useful as in this example) message.

If something goes REALLY bad, you can also use the default error page:

PHPWS_Core::errorPage();

This just prints a simple html page that indicates something went
quite wrong. The script then exits. You may see it if your database
goes down or a file goes missing.



H. Security
----------------------------------------------------------------------
Some final warnings before leaving this chapter.
1) Parse all text coming in from post and get arrays.
2) Parse all text coming in from a cookie.
3) If you are expecting an integer, cast the variable with an (INT).
4) For each php file you create, prevent any action from direct
access. In other words, don't let a hacker browse directly to that
file and run your script.




III. Installation
______________________________________________________________________

   A. Modules
----------------------------------------------------------------------



   B. Directories
----------------------------------------------------------------------



   C. Boost
----------------------------------------------------------------------



   D. Permissions
----------------------------------------------------------------------

I will touch on permissioning here. A more detailed account can
(eventually not finished writing it yet) be found in
docs/Permission.txt. Checking for permissions is handled in part IV.

There are five types of users:

anonymous    - this user isn't logged in to the system

logged       - this user is logged in, but doesn't have any
               administrative permissions

restricted   - this user is logged in and has restricted admin
               privileges. These users can edit items but their
               changes are subject to approval

unrestricted - logged in user with full permissions in one module or
               more. Their changes are not subject to approval

deity        - an all-powerful logged in user. They have access to any
               module, can view any item, and often use some
               administrative functions or modules that mere mortals
               are not allowed to touch.


Before you start adding permissions to your module, you need to create
a permission configuration file.

The permission.php file is saved in your module's boost directory. If
you only want your module to have all or nothing permissions. Just
add:

$user_permissions = true;

and save the permission file. This indicates you not be using
sub-permissions (explained in a second) or item permissions. The only
to administrative options would be no permissions and all permissions.

You may also include sub-permissions for your modules. For example,
say you wanted to specify the administrators who may delete items from
your module. Add a subpermission like so:

$permissions['delete'] = _('Delete item')

Finally, you may narrow down permissions to specific items. Just set:

$item_permissions = true;

Let's look at what a completed permissions file would look like:

<?php
$use_permissions = TRUE;

$permissions['edit_items']   = _('Edit items');
$permissions['delete_items'] = _('Delete items');

$item_permissions = TRUE;
?>

Users would read this file and know,
1) the module wants to use permissioning
2) it will use subpermissions for editing and deleting and
3) it will allow the admin to set item permissions.



IV.  Administrating
______________________________________________________________________


   A. Permissions
----------------------------------------------------------------------



   B. Control Panel
----------------------------------------------------------------------



   C. Settings
----------------------------------------------------------------------



   D. Form Class
----------------------------------------------------------------------



   E. Files
----------------------------------------------------------------------



     1. Images
......................................................................



     2. Files
......................................................................



   F. DBPager
----------------------------------------------------------------------



   G. Mini Admin
----------------------------------------------------------------------




V.   Users and Layouts
______________________________________________________________________



   A. Layout
----------------------------------------------------------------------



   B. Javascript
----------------------------------------------------------------------



   C. Key Flag
----------------------------------------------------------------------



   D. Caching
----------------------------------------------------------------------




VI.  Advanced and Miscellaneous
______________________________________________________________________



   A. Approval
----------------------------------------------------------------------



   B. Versioning
----------------------------------------------------------------------


   C. Cookies
----------------------------------------------------------------------



   D. SmartTags
----------------------------------------------------------------------

